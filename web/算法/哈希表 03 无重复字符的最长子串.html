<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<script>
			/*
      给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。
      示例 1:
      输入: s = "abcabcbb"
      输出: 3 
      解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
      示例 2:
      输入: s = "bbbbb"
      输出: 1
      解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
      示例 3:
      输入: s = "pwwkew"
      输出: 3
      解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
      */
			/**
			 * @param {string} s
			 * @return {number}
			 */
			// var lengthOfLongestSubstring = function (s) {
			// 	let map = new Map();
			// 	for (let i = 0; i < s.length; i++) {
			// 		for (let j = i + 1; j <= s.length; j++) {
			// 			const subStr = s.substring(i, j); //枚举每一项
			// 			if (new Set(subStr).size === subStr.length) {
			// 				//去重
			// 				map.set(subStr, subStr.length);
			// 			} else {
			// 				break;
			// 			}
			// 		}
			// 	}
			// 	if (map.size === 0) {
			// 		return 0;
			// 	}
			// 	const maxValue = Math.max(...Array.from(map.values()));
			// 	return maxValue;
			// };
			// lengthOfLongestSubstring('pwwkew');
			var lengthOfLongestSubstring = function (s) {
				let maxLength = 0;
				// 用于存储字符及其最新出现的索引
				let charMap = new Map();
				// 滑动窗口的左边界
				let left = 0;
				for (let right = 0; right < s.length; right++) {
					const currentChar = s[right];
					// 如果字符已经在 Map 中，并且其索引在当前窗口内
					if (charMap.has(currentChar) && charMap.get(currentChar) >= left) {
						// 移动左边界到重复字符的下一个位置
						left = charMap.get(currentChar) + 1;
					}
					// 更新字符的最新索引
					charMap.set(currentChar, right);
					// 计算当前窗口的长度并更新最大长度
					maxLength = Math.max(maxLength, right - left + 1);
				}

				return maxLength;
			};
		</script>
	</body>
</html>
